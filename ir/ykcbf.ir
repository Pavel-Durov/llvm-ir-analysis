; Module: ld-temp.o
; Generated during stackmap processing

; ModuleID = 'ld-temp.o'
source_filename = "ld-temp.o"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.YkLocation = type { i64 }
%struct.stat = type { i64, i64, i64, i32, i32, i32, i32, i64, i64, i64, i64, %struct.timespec, %struct.timespec, %struct.timespec, [3 x i64] }
%struct.timespec = type { i64, i64 }

@.str = private unnamed_addr constant [14 x i8] c"out of memory\00", align 1
@.str.1 = private unnamed_addr constant [9 x i8] c"(stdout)\00", align 1
@.str.2 = private unnamed_addr constant [8 x i8] c"(stdin)\00", align 1
@.str.3 = private unnamed_addr constant [11 x i8] c"<filename>\00", align 1
@.str.4 = private unnamed_addr constant [3 x i8] c"%s\00", align 1
@stdout = external dso_local local_unnamed_addr global ptr, align 8
@shadowstack_size = global i32 1000000, section ".rodata"
@shadowstack_0 = thread_local global ptr null
@shadowstack_head = thread_local global ptr null

; Function Attrs: noinline nounwind optnone uwtable
define dso_local void @interp(ptr noundef %0, ptr noundef readnone %1, ptr noundef %2, ptr noundef readnone %3, ptr noundef %4, ptr noundef %5) local_unnamed_addr #0 {
  call void @__yk_trace_basicblock(i32 0, i32 0)
  %7 = icmp ult ptr %0, %1
  call void (i64, i32, ...) @llvm.experimental.stackmap(i64 1, i32 0, ptr %0, ptr %1, ptr %2, ptr %3, ptr %4, ptr %5, i1 %7)
  br i1 %7, label %8, label %67

8:                                                ; preds = %6
  call void @__yk_trace_basicblock(i32 0, i32 1)
  %9 = ptrtoint ptr %0 to i64
  br label %10

10:                                               ; preds = %61, %8
  %11 = phi ptr [ %2, %8 ], [ %63, %61 ]
  %12 = phi ptr [ %0, %8 ], [ %64, %61 ]
  call void @__yk_trace_basicblock(i32 0, i32 2)
  %13 = ptrtoint ptr %12 to i64
  %14 = sub i64 %13, %9
  %15 = getelementptr inbounds %struct.YkLocation, ptr %5, i64 %14
  call void (i64, i32, ptr, i32, ...) @llvm.experimental.patchpoint.void(i64 0, i32 13, ptr @__ykrt_control_point, i32 3, ptr %4, ptr %15, i64 0, ptr %1, ptr %2, ptr %3, ptr %4, ptr %5, i64 %9, ptr %11, ptr %12)
  br label %16

16:                                               ; preds = %10
  call void @__yk_trace_basicblock(i32 0, i32 3)
  %17 = load i8, ptr %12, align 1, !tbaa !5
  %18 = sext i8 %17 to i32
  call void (i64, i32, ...) @llvm.experimental.stackmap(i64 2, i32 0, ptr %1, ptr %2, ptr %3, ptr %4, ptr %5, i64 %9, ptr %11, ptr %12, i32 %18)
  switch i32 %18, label %61 [
    i32 62, label %19
    i32 60, label %24
    i32 43, label %28
    i32 45, label %31
    i32 46, label %34
    i32 44, label %43
    i32 91, label %49
    i32 93, label %55
  ]

19:                                               ; preds = %16
  call void @__yk_trace_basicblock(i32 0, i32 4)
  %20 = getelementptr inbounds i8, ptr %11, i64 1
  %21 = icmp eq ptr %11, %3
  call void (i64, i32, ...) @llvm.experimental.stackmap(i64 3, i32 0, ptr %1, ptr %2, ptr %3, ptr %4, ptr %5, i64 %9, ptr %12, ptr %20, i1 %21)
  br i1 %21, label %22, label %61

22:                                               ; preds = %19
  call void @__yk_trace_basicblock(i32 0, i32 5)
  tail call void (i32, ptr, ...) @errx(i32 noundef 1, ptr noundef nonnull @.str) #14
  br label %23

23:                                               ; preds = %22
  call void @__yk_trace_basicblock(i32 0, i32 6)
  unreachable

24:                                               ; preds = %16
  call void @__yk_trace_basicblock(i32 0, i32 7)
  %25 = icmp ugt ptr %11, %2
  %26 = sext i1 %25 to i64
  %27 = getelementptr inbounds i8, ptr %11, i64 %26
  br label %61

28:                                               ; preds = %16
  call void @__yk_trace_basicblock(i32 0, i32 8)
  %29 = load i8, ptr %11, align 1, !tbaa !5
  %30 = add i8 %29, 1
  store i8 %30, ptr %11, align 1, !tbaa !5
  br label %61

31:                                               ; preds = %16
  call void @__yk_trace_basicblock(i32 0, i32 9)
  %32 = load i8, ptr %11, align 1, !tbaa !5
  %33 = add i8 %32, -1
  store i8 %33, ptr %11, align 1, !tbaa !5
  br label %89

34:                                               ; preds = %16
  call void @__yk_trace_basicblock(i32 0, i32 10)
  %35 = load i8, ptr %11, align 1, !tbaa !5
  %36 = sext i8 %35 to i32
  %37 = load ptr, ptr @stdout, align 8, !tbaa !8
  %38 = tail call i32 @putc(i32 noundef %36, ptr noundef %37)
  br label %39

39:                                               ; preds = %34
  call void @__yk_trace_basicblock(i32 0, i32 11)
  %40 = icmp eq i32 %38, -1
  call void (i64, i32, ...) @llvm.experimental.stackmap(i64 4, i32 0, ptr %1, ptr %2, ptr %3, ptr %4, ptr %5, i64 %9, ptr %11, ptr %12, i1 %40)
  br i1 %40, label %41, label %89

41:                                               ; preds = %39
  call void @__yk_trace_basicblock(i32 0, i32 12)
  tail call void (i32, ptr, ...) @err(i32 noundef 1, ptr noundef nonnull @.str.1) #12
  br label %42

42:                                               ; preds = %41
  call void @__yk_trace_basicblock(i32 0, i32 13)
  unreachable

43:                                               ; preds = %16
  call void @__yk_trace_basicblock(i32 0, i32 14)
  %44 = tail call i64 @read(i32 noundef 0, ptr noundef %11, i64 noundef 1) #13
  br label %45

45:                                               ; preds = %43
  call void @__yk_trace_basicblock(i32 0, i32 15)
  %46 = icmp eq i64 %44, -1
  call void (i64, i32, ...) @llvm.experimental.stackmap(i64 5, i32 0, ptr %1, ptr %2, ptr %3, ptr %4, ptr %5, i64 %9, ptr %11, ptr %12, i1 %46)
  br i1 %46, label %47, label %89

47:                                               ; preds = %45
  call void @__yk_trace_basicblock(i32 0, i32 16)
  tail call void (i32, ptr, ...) @err(i32 noundef 1, ptr noundef nonnull @.str.2) #12
  br label %48

48:                                               ; preds = %47
  call void @__yk_trace_basicblock(i32 0, i32 17)
  unreachable

49:                                               ; preds = %16
  call void @__yk_trace_basicblock(i32 0, i32 18)
  %50 = load i8, ptr %11, align 1, !tbaa !5
  %51 = icmp eq i8 %50, 0
  call void (i64, i32, ...) @llvm.experimental.stackmap(i64 6, i32 0, ptr %1, ptr %2, ptr %3, ptr %4, ptr %5, i64 %9, ptr %11, ptr %12, i1 %51)
  br i1 %51, label %52, label %89

52:                                               ; preds = %49
  call void @__yk_trace_basicblock(i32 0, i32 19)
  br label %53

53:                                               ; preds = %52, %64
  %54 = phi ptr [ %65, %64 ], [ %12, %52 ]
  %55 = phi i32 [ %67, %64 ], [ 0, %52 ]
  call void @__yk_trace_basicblock(i32 0, i32 20)
  br label %56

56:                                               ; preds = %96, %53
  %57 = phi ptr [ %58, %96 ], [ %54, %53 ]
  call void @__yk_trace_basicblock(i32 0, i32 21)
  %58 = getelementptr inbounds i8, ptr %57, i64 1
  %59 = load i8, ptr %58, align 1, !tbaa !5
  call void (i64, i32, ...) @llvm.experimental.stackmap(i64 7, i32 0, ptr %1, ptr %2, ptr %3, ptr %4, ptr %5, i64 %9, ptr %11, i32 %55, ptr %58, i8 %59)
  switch i8 %59, label %96 [
    i8 93, label %60
    i8 91, label %63
  ]

60:                                               ; preds = %56
  %61 = phi ptr [ %58, %56 ]
  call void @__yk_trace_basicblock(i32 0, i32 22)
  %62 = icmp eq i32 %55, 0
  call void (i64, i32, ...) @llvm.experimental.stackmap(i64 8, i32 0, ptr %1, ptr %2, ptr %3, ptr %4, ptr %5, i64 %9, ptr %11, i32 %55, ptr %61, i1 %62)
  br i1 %62, label %87, label %64

63:                                               ; preds = %56
  call void @__yk_trace_basicblock(i32 0, i32 23)
  br label %64

64:                                               ; preds = %63, %60
  %65 = phi ptr [ %61, %60 ], [ %58, %63 ]
  %66 = phi i32 [ -1, %60 ], [ 1, %63 ]
  call void @__yk_trace_basicblock(i32 0, i32 24)
  %67 = add nsw i32 %55, %66
  br label %53

68:                                               ; preds = %16
  call void @__yk_trace_basicblock(i32 0, i32 25)
  %69 = load i8, ptr %11, align 1, !tbaa !5
  %70 = icmp eq i8 %69, 0
  call void (i64, i32, ...) @llvm.experimental.stackmap(i64 9, i32 0, ptr %1, ptr %2, ptr %3 %1
  call void (i64, i32, ...) @llvm.experimental.stackmap(i64 10, i32 0, ptr %1, ptr %2, ptr %3, ptr %4, ptr %5, i64 %9, ptr %63, ptr %64, i1 %65)
  br i1 %65, label %10, label %66, !llvm.loop !10

66:                                               ; preds = %61
  call void @__yk_trace_basicblock(i32 0, i32 25)
  br label %67

67:                                               ; preds = %66, %6
  call void @__yk_trace_basicblock(i32 0, i32 26)
  br label %69

68:                                               ; preds = %69
  call void @__yk_trace_basicblock(i32 0, i32 27)
  ret void

69:                                               ; preds = %67
  call void @__yk_trace_basicblock(i32 0, i32 28)
  br label %68
}

declare dso_local void @yk_mt_control_point(ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: cold noreturn
declare dso_local void @errx(i32 noundef, ptr noundef, ...) local_unnamed_addr #2

; Function Attrs: nofree nounwind
declare dso_local noundef i32 @putc(i32 noundef, ptr nocapture noundef) local_unnamed_addr #3

; Function Attrs: cold noreturn
declare dso_local void @err(i32 noundef, ptr noundef, ...) local_unnamed_addr #2

; Function Attrs: nofree
declare dso_local noundef i64 @read(i32 noundef, ptr nocapture noundef, i64 noundef) local_unnamed_addr #4

; Function Attrs: nofree noinline norecurse nosync nounwind memory(read, inaccessiblemem: none) uwtable
define dso_local nonnull ptr @jmp_fwd(ptr noundef readonly %0) local_unnamed_addr #5 {
  br label %2

2:                                                ; preds = %14, %1
  %3 = phi ptr [ %0, %1 ], [ %7, %14 ]
  %4 = phi i32 [ 0, %1 ], [ %16, %14 ]
  br label %5

5:                                                ; preds = %5, %2
  %6 = phi ptr [ %7, %5 ], [ %3, %2 ]
  %7 = getelementptr inbounds i8, ptr %6, i64 1
  %8 = load i8, ptr %7, align 1, !tbaa !5
  %9 = zext i8 %8 to i32
  switch i32 %9, label %5 [
    i32 93, label %10
    i32 91, label %13
  ]

10:                                               ; preds = %5
  %11 = icmp eq i32 %4, 0
  br i1 %11, label %12, label %14

12:                                               ; preds = %10
  ret ptr %7

13:                                               ; preds = %5
  br label %14

14:                                               ; preds = %13, %10
  %15 = phi i32 [ -1, %10 ], [ 1, %13 ]
  %16 = add nsw i32 %4, %15
  br label %2
}

; Function Attrs: nofree noinline norecurse nosync nounwind memory(read, inaccessiblemem: none) uwtable
define dso_local nonnull ptr @jmp_back(ptr noundef readonly %0) local_unnamed_addr #5 {
  br label %2

2:                                                ; preds = %14, %1
  %3 = phi ptr [ %0, %1 ], [ %7, %14 ]
  %4 = phi i32 [ 0, %1 ], [ %16, %14 ]
  br label %5

5:                                                ; preds = %5, %2
  %6 = phi ptr [ %7, %5 ], [ %3, %2 ]
  %7 = getelementptr inbounds i8, ptr %6, i64 -1
  %8 = load i8, ptr %7, align 1, !tbaa !5
  %9 = zext i8 %8 to i32
  switch i32 %9, label %5 [
    i32 91, label %10
    i32 93, label %13
  ]

10:                                               ; preds = %5
  %11 = icmp eq i32 %4, 0
  br i1 %11, label %12, label %14

12:                                               ; preds = %10
  ret ptr %7

13:                                               ; preds = %5
  br label %14

14:                                               ; preds = %13, %10
  %15 = phi i32 [ -1, %10 ], [ 1, %13 ]
  %16 = add nsw i32 %4, %15
  br label %2
}

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @main(i32 noundef %0, ptr nocapture noundef readonly %1) local_unnamed_addr #6 {
  %3 = call ptr @malloc(i64 1000000)
  %4 = getelementptr i8, ptr %3, i32 144
  store ptr %3, ptr @shadowstack_head, align 8
  store ptr %4, ptr @shadowstack_0, align 8
  %5 = getelementptr i8, ptr %3, i32 0
  %6 = icmp slt i32 %0, 2
  br i1 %6, label %7, label %8

7:                                                ; preds = %2
  tail call void (i32, ptr, ...) @errx(i32 noundef 1, ptr noundef nonnull @.str.3) #14
  unreachable

8:                                                ; preds = %2
  %9 = getelementptr inbounds ptr, ptr %1, i64 1
  %10 = load ptr, ptr %9, align 8, !tbaa !8
  %11 = tail call i32 (ptr, i32, ...) @open(ptr noundef %10, i32 noundef 0) #15
  call void @llvm.lifetime.start.p0(i64 144, ptr nonnull %5) #15
  %12 = call i32 @fstat(i32 noundef %11, ptr noundef nonnull %5) #15
  %13 = icmp eq i32 %12, 0
  br i1 %13, label %17, label %14

14:                                               ; preds = %8
  %15 = getelementptr inbounds i8, ptr %1, i64 8
  %16 = load ptr, ptr %15, align 8, !tbaa !8
  tail call void (i32, ptr, ...) @err(i32 noundef 1, ptr noundef nonnull @.str.4, ptr noundef %16) #14
  unreachable

17:                                               ; preds = %8
  %18 = getelementptr inbounds %struct.stat, ptr %5, i64 0, i32 8
  %19 = load i64, ptr %18, align 8, !tbaa !12
  %20 = tail call noalias ptr @malloc(i64 noundef %19) #16
  %21 = icmp eq ptr %20, null
  br i1 %21, label %22, label %23

22:                                               ; preds = %17
  tail call void (i32, ptr, ...) @err(i32 noundef 1, ptr noundef nonnull @.str) #14
  unreachable

23:                                               ; preds = %17
  %24 = tail call i64 @read(i32 noundef %11, ptr noundef nonnull %20, i64 noundef %19) #15
  %25 = icmp eq i64 %24, %19
  br i1 %25, label %29, label %26

26:                                               ; preds = %23
  %27 = getelementptr inbounds i8, ptr %1, i64 8
  %28 = load ptr, ptr %27, align 8, !tbaa !8
  tail call void (i32, ptr, ...) @err(i32 noundef 1, ptr noundef nonnull @.str.4, ptr noundef %28) #14
  unreachable

29:                                               ; preds = %23
  %30 = tail call noalias dereferenceable_or_null(30000) ptr @calloc(i64 noundef 1, i64 noundef 30000) #17
  %31 = icmp eq ptr %30, null
  br i1 %31, label %32, label %33

32:                                               ; preds = %29
  tail call void (i32, ptr, ...) @err(i32 noundef 1, ptr noundef nonnull @.str) #14
  unreachable

33:                                               ; preds = %29
  %34 = tail call ptr @yk_mt_new(ptr noundef null) #15
  %35 = tail call noalias ptr @calloc(i64 noundef %19, i64 noundef 8) #17
  %36 = icmp eq ptr %35, null
  br i1 %36, label %40, label %37

37:                                               ; preds = %33
  %38 = icmp eq i64 %19, 0
  br i1 %38, label %41, label %39

39:                                               ; preds = %37
  br label %44

40:                                               ; preds = %33
  tail call void (i32, ptr, ...) @err(i32 noundef 1, ptr noundef nonnull @.str) #14
  unreachable

41:                                               ; preds = %53, %37
  %42 = getelementptr inbounds i8, ptr %20, i64 %19
  %43 = getelementptr inbounds i8, ptr %30, i64 30000
  tail call void @interp(ptr noundef nonnull %20, ptr noundef nonnull %42, ptr noundef nonnull %30, ptr noundef nonnull %43, ptr noundef %34, ptr noundef nonnull %35)
  tail call void @free(ptr noundef nonnull %35) #15
  call void @llvm.lifetime.end.p0(i64 144, ptr nonnull %5) #15
  ret i32 0

44:                                               ; preds = %39, %53
  %45 = phi i64 [ %57, %53 ], [ 0, %39 ]
  %46 = getelementptr inbounds i8, ptr %20, i64 %45
  %47 = load i8, ptr %46, align 1, !tbaa !5
  %48 = icmp eq i8 %47, 93
  br i1 %48, label %49, label %51

49:                                               ; preds = %44
  %50 = tail call i64 @yk_location_new() #15
  br label %53

51:                                               ; preds = %44
  %52 = tail call i64 @yk_location_null() #15
  br label %53

53:                                               ; preds = %51, %49
  %54 = phi i64 [ %50, %49 ], [ %52, %51 ]
  %55 = shl i64 %45, 3
  %56 = getelementptr i8, ptr %35, i64 %55
  store i64 %54, ptr %56, align 8
  %57 = add nuw i64 %45, 1
  %58 = icmp eq i64 %19, %57
  br i1 %58, label %41, label %44, !llvm.loop !17
}

; Function Attrs: nofree
declare dso_local noundef i32 @open(ptr nocapture noundef readonly, i32 noundef, ...51:                                               ; preds = %44
  %52 = tail call i64 @yk_location_null() #13
  br label %53

53:                                               ; preds = %51, %49
  %54 = phi i64 [ %50, %49 ], [ %52, %51 ]
  %55 = shl i64 %45, 3
  %56 = getelementptr i8, ptr %35, i64 %55
  store i64 %54, ptr %56, align 8
  %57 = add nuw i64 %45, 1
  %58 = icmp eq i64 %19, %57
  br i1 %58, label %41, label %44, !llvm.loop !17
}

; Function Attrs: nofree
declare dso_local noundef i32 @open(ptr nocapture noundef readonly, i32 noundef, ...) local_unnamed_addr #4

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #6

; Function Attrs: nofree nounwind
declare dso_local noundef i32 @fstat(i32 noundef, ptr nocapture noundef) local_unnamed_addr #3

; Function Attrs: mustprogress nofree nounwind willreturn allockind("alloc,uninitialized") allocsize(0) memory(inaccessiblemem: readwrite)
declare dso_local noalias noundef ptr @malloc(i64 noundef) local_unnamed_addr #7

; Function Attrs: mustprogress nofree nounwind willreturn allockind("alloc,zeroed") allocsize(0,1) memory(inaccessiblemem: readwrite)
declare dso_local noalias noundef ptr @calloc(i64 noundef, i64 noundef) local_unnamed_addr #8

declare dso_local ptr @yk_mt_new(ptr noundef) local_unnamed_addr #1

; Function Attrs: mustprogress nounwind willreturn allockind("free") memory(argmem: readwrite, inaccessiblemem: readwrite)
declare dso_local void @free(ptr allocptr nocapture noundef) local_unnamed_addr #9

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #6

declare dso_local i64 @yk_location_new() local_unnamed_addr #1

declare dso_local i64 @yk_location_null() local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local i32 @__yk_opt_main(i32 noundef %0, ptr nocapture noundef readonly %1) local_unnamed_addr #10 !__yk_opt_ !18 {
  %3 = alloca %struct.stat, align 8
  %4 = icmp slt i32 %0, 2
  br i1 %4, label %5, label %6

5:                                                ; preds = %2
  tail call void (i32, ptr, ...) @errx(i32 noundef 1, ptr noundef nonnull @.str.3) #12
  unreachable

6:                                                ; preds = %2
  %7 = getelementptr inbounds ptr, ptr %1, i64 1
  %8 = load ptr, ptr %7, align 8, !tbaa !8
  %9 = tail call i32 (ptr, i32, ...) @open(ptr noundef %8, i32 noundef 0) #13
  call void @llvm.lifetime.start.p0(i64 144, ptr nonnull %3) #13
  %10 = call i32 @fstat(i32 noundef %9, ptr noundef nonnull %3) #13
  %11 = icmp eq i32 %10, 0
  br i1 %11, label %15, label %12

12:                                               ; preds = %6
  %13 = getelementptr inbounds i8, ptr %1, i64 8
  %14 = load ptr, ptr %13, align 8, !tbaa !8
  tail call void (i32, ptr, ...) @err(i32 noundef 1, ptr noundef nonnull @.str.4, ptr noundef %14) #12
  unreachable

15:                                               ; preds = %6
  %16 = getelementptr inbounds %struct.stat, ptr %3, i64 0, i32 8
  %17 = load i64, ptr %16, align 8, !tbaa !12
  %18 = tail call noalias ptr @malloc(i64 noundef %17) #14
  %19 = icmp eq ptr %18, null
  br i1 %19, label %20, label %21

20:                                               ; preds = %15
  tail call void (i32, ptr, ...) @err(i32 noundef 1, ptr noundef nonnull @.str) #12
  unreachable

21:                                               ; preds = %15
  %22 = tail call i64 @read(i32 noundef %9, ptr noundef nonnull %18, i64 noundef %17) #13
  %23 = icmp eq i64 %22, %17
  br i1 %23, label %27, label %24

24:                                               ; preds = %21
  %25 = getelementptr inbounds i8, ptr %1, i64 8
  %26 = load ptr, ptr %25, align 8, !tbaa !8
  tail call void (i32, ptr, ...) @err(i32 noundef 1, ptr noundef nonnull @.str.4, ptr noundef %26) #12
  unreachable

27:                                               ; preds = %21
  %28 = tail call noalias dereferenceable_or_null(30000) ptr @calloc(i64 noundef 1, i64 noundef 30000) #15
  %29 = icmp eq ptr %28, null
  br i1 %29, label %30, label %31

30:                                               ; preds = %27
  tail call void (i32, ptr, ...) @err(i32 noundef 1, ptr noundef nonnull @.str) #12
  unreachable

31:                                               ; preds = %27
  %32 = tail call ptr @yk_mt_new(ptr noundef null) #13
  %33 = tail call noalias ptr @calloc(i64 noundef %17, i64 noundef 8) #15
  %34 = icmp eq ptr %33, null
  br i1 %34, label %38, label %35

35:                                               ; preds = %31
  %36 = icmp eq i64 %17, 0
  br i1 %36, label %39, label %37

37:                                               ; preds = %35
  br label %42

38:                                               ; preds = %31
  tail call void (i32, ptr, ...) @err(i32 noundef 1, ptr noundef nonnull @.str) #12
  unreachable

39:                                               ; preds = %51, %35
  %40 = getelementptr inbounds i8, ptr %18, i64 %17
  %41 = getelementptr inbounds i8, ptr %28, i64 30000
  tail call void @interp(ptr noundef nonnull %18, ptr noundef nonnull %40, ptr noundef nonnull %28, ptr noundef nonnull %41, ptr noundef %32, ptr noundef nonnull %33)
  tail call void @free(ptr noundef nonnull %33) #13
  call void @llvm.lifetime.end.p0(i64 144, ptr nonnull %3) #13
  ret i32 0

42:                                               ; preds = %37, %51
  %43 = phi i64 [ %55, %51 ], [ 0, %37 ]
  %44 = getelementptr inbounds i8, ptr %18, i64 %43
  %45 = load i8, ptr %44, align 1, !tbaa !5
  %46 = icmp eq i8 %45, 93
  br i1 %46, label %47, label %49

47:                                               ; preds = %42
  %48 = tail call i64 @yk_location_new() #13
  br label %51

49:                                               ; preds = %42
  %50 = tail call i64 @yk_location_null() #13
  br label %51

51:                                               ; preds = %49, %47
  %52 = phi i64 [ %48, %47 ], [ %50, %49 ]
  %53 = shl i64 %43, 3
  %54 = getelementptr i8, ptr %33, i64 %53
  store i64 %52, ptr %54, align 8
  %55 = add nuw i64 %43, 1
  %56 = icmp eq i64 %17, %55
  br i1 %56, label %39, label %42, !llvm.loop !17
}

declare void @__ykrt_control_point(ptr, ptr, i64)

declare void @llvm.experimental.patchpoint.void(i64, i32, ptr, i32, ...)

; Function Attrs: nocallback nofree nosync willreturn
declare void @llvm.experimental.stackmap(i64, i32, ...) #11

declare void @__yk_trace_basicblock(i32, i32)

attributes #0 = { noinline nounwind optnone uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" "yk_outline" }
attributes #1 = { "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #2 = { cold noreturn "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #3 = { nofree nounwind "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #4 = { nofree "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #5 = { noinline nounwind uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" "yk_outline" }
attributes #6 = { mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #7 = { mustprogress nofree nounwind willreturn allockind("alloc,uninitialized") allocsize(0) memory(inaccessiblemem: readwrite) "alloc-family"="malloc" "no-trapping-math"="true" "stack-protector-buffer-svm.experimental.stackmap(i64, i32, ...) #13

declare void @__yk_trace_basicblock(i32, i32)

attributes #0 = { noinline nounwind optnone uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" "yk_outline" }
attributes #1 = { "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #2 = { cold noreturn "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #3 = { nofree nounwind "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #4 = { nofree "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #5 = { nofree noinline norecurse nosync nounwind memory(read, inaccessiblemem: none) uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" "yk_outline" }
attributes #6 = { noinline nounwind uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" "yk_outline" }
attributes #7 = { mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #8 = { mustprogress nofree nounwind willreturn allockind("alloc,uninitialized") allocsize(0) memory(inaccessiblemem: readwrite) "alloc-family"="malloc" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #9 = { mustprogress nofree nounwind willreturn allockind("alloc,zeroed") allocsize(0,1) memory(inaccessiblemem: readwrite) "alloc-family"="malloc" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #10 = { mustprogress nounwind willreturn allockind("free") memory(argmem: readwrite, inaccessiblemem: readwrite) "alloc-family"="malloc" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #11 = { nofree norecurse nosync nounwind memory(read, inaccessiblemem: none) uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" "yk_outline" }
attributes #12 = { nounwind uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" "yk_outline" }
attributes #13 = { nocallback nofree nosync willreturn }
attributes #14 = { cold noreturn nounwind }
attributes #15 = { nounwind }
attributes #16 = { nounwind allocsize(0) }
attributes #17 = { nounwind allocsize(0,1) }

!llvm.ident = !{!0}
!llvm.module.flags = !{!1, !2, !3, !4}

!0 = !{!"clang version 18.0.0 (git@github.com:ykjit/ykllvm 8f6d1549171e0d30e2cd8a77a4bd7b35c795da3f)"}
!1 = !{i32 1, !"wchar_size", i32 4}
!2 = !{i32 7, !"uwtable", i32 2}
!3 = !{i32 1, !"ThinLTO", i32 0}
!4 = !{i32 1, !"EnableSplitLTOUnit", i32 1}
!5 = !{!6, !6, i64 0}
!6 = !{!"omnipotent char", !7, i64 0}
!7 = !{!"Simple C/C++ TBAA"}
!8 = !{!9, !9, i64 0}
!9 = !{!"any pointer", !6, i64 0}
!10 = distinct !{!10, !11}
!11 = !{!"llvm.loop.mustprogress"}
!12 = !{!13, !14, i64 48}
!13 = !{!"stat", !14, i64 0, !14, i64 8, !14, i64 16, !15, i64 24, !15, i64 28, !15, i64 32, !15, i64 36, !14, i64 40, !14, i64 48, !14, i64 56, !14, i64 64, !16, i64 72, !16, i64 88, !16, i64 104, !6, i64 120}
!14 = !{!"long", !6, i64 0}
!15 = !{!"int", !6, i64 0}
!16 = !{!"timespec", !14, i64 0, !14, i64 8}
!17 = distinct !{!17, !11}
!18 = !{!""}
